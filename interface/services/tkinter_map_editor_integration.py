# services/tkinter_map_editor_integration.py
"""
Serviço de integração para acessar o editor Tkinter de mapas via interface web.

Este módulo fornece uma ponte entre a interface Streamlit e o editor Tkinter,
permitindo que usuários acessem o editor gráfico nativo através da web.
"""
import os
import sys
import subprocess
import threading
import time
from pathlib import Path
from typing import Optional, Dict, List
import streamlit as st

# Adicionar o módulo de criação de mapas ao path
current_dir = Path(__file__).parent
project_root = current_dir.parent.parent
map_creation_module = project_root / "modulo_criacao_mapas"
sys.path.append(str(map_creation_module))

try:
    from pixel_map_editor import create_map_editor, launch_map_editor
except ImportError as e:
    st.error(f"Erro ao importar editor Tkinter: {e}")
    create_map_editor = None
    launch_map_editor = None

class TkinterMapEditorIntegration:
    """Classe para integração do editor Tkinter com a interface web."""
    
    def __init__(self):
        self.mapas_dir = Path("mapas")
        self.mapas_dir.mkdir(exist_ok=True)
        self.editor_process = None
        
        # Cores padrão do sistema (mesmo esquema do editor Tkinter)
        self.colors = {
            'Parede': ((0, 0, 0), '#000000', '1'),
            'Espaço vazio': ((255, 255, 255), '#FFFFFF', '0'),
            'Tapete/Caminho': ((255, 165, 0), '#FFA500', '9'),
            'Porta/Saída': ((255, 0, 0), '#FF0000', '2'),
            'Janelas': ((0, 255, 0), '#00FF00', '7'),
            'Inocupável': ((192, 192, 192), '#C0C0C0', '8'),
        }
    
    def get_color_scheme(self) -> Dict[str, tuple]:
        """Retorna o esquema de cores padrão."""
        return self.colors
    
    def launch_tkinter_editor(self, width_px: int = 20, height_px: int = 20, cell_size: int = 25) -> bool:
        """
        Lança o editor Tkinter em um processo separado.
        
        Args:
            rows: Número de linhas do mapa
            cols: Número de colunas do mapa
            cell_size: Tamanho de cada célula em pixels
            
        Returns:
            bool: True se o editor foi lançado com sucesso
        """
        if create_map_editor is None:
            st.error("Editor Tkinter não disponível")
            return False
        
        try:
            # Criar script temporário para lançar o editor
            script_content = f"""
import sys
sys.path.append('{map_creation_module}')
from pixel_map_editor import create_map_editor
import os

# Configurar diretório de salvamento
auto_save_dir = '{self.mapas_dir.absolute()}'

"""Map editor launcher generated by Streamlit"""
# Criar e executar editor (cols = largura, rows = altura)
editor = create_map_editor(
    rows={height_px}, 
    cols={width_px}, 
    cell_size={cell_size},
    auto_save_dir=auto_save_dir,
    web_integration=True
)
editor.mainloop()
"""
            
            # Salvar script temporário
            script_path = self.mapas_dir / "temp_editor_launcher.py"
            with open(script_path, 'w') as f:
                f.write(script_content)
            
            # Lançar editor em processo separado
            self.editor_process = subprocess.Popen([
                sys.executable, str(script_path)
            ], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            
            # Limpar script temporário após um tempo
            def cleanup():
                time.sleep(2)
                if script_path.exists():
                    try:
                        script_path.unlink()
                    except:
                        pass
            
            threading.Thread(target=cleanup, daemon=True).start()
            
            return True
            
        except Exception as e:
            st.error(f"Erro ao lançar editor Tkinter: {e}")
            return False
    
    def launch_simple_editor(self) -> bool:
        """
        Lança o editor Tkinter com configuração padrão.
        
        Returns:
            bool: True se o editor foi lançado com sucesso
        """
        if launch_map_editor is None:
            st.error("Editor Tkinter não disponível")
            return False
        
        try:
            # Lançar editor com configuração padrão
            self.editor_process = subprocess.Popen([
                sys.executable, "-c", 
                f"import sys; sys.path.append('{map_creation_module}'); "
                f"from pixel_map_editor import launch_map_editor; launch_map_editor()"
            ], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            
            return True
            
        except Exception as e:
            st.error(f"Erro ao lançar editor Tkinter: {e}")
            return False
    
    def check_editor_status(self) -> Dict[str, any]:
        """
        Verifica o status do editor Tkinter.
        
        Returns:
            Dict: Status do editor
        """
        if self.editor_process is None:
            return {"running": False, "message": "Nenhum editor em execução"}
        
        poll_result = self.editor_process.poll()
        if poll_result is None:
            return {"running": True, "message": "Editor em execução"}
        else:
            return {"running": False, "message": f"Editor finalizado (código: {poll_result})"}
    
    def get_recent_maps(self) -> List[Path]:
        """
        Retorna lista de mapas criados recentemente.
        
        Returns:
            List[Path]: Lista de arquivos de mapa PNG
        """
        try:
            # Buscar arquivos PNG no diretório de mapas
            png_files = list(self.mapas_dir.glob("*.png"))
            
            # Ordenar por data de modificação (mais recentes primeiro)
            png_files.sort(key=lambda x: x.stat().st_mtime, reverse=True)
            
            return png_files
            
        except Exception as e:
            st.error(f"Erro ao buscar mapas: {e}")
            return []
    
    def get_map_info(self, map_path: Path) -> Dict[str, any]:
        """
        Obtém informações sobre um mapa.
        
        Args:
            map_path: Caminho para o arquivo de mapa
            
        Returns:
            Dict: Informações do mapa
        """
        try:
            from PIL import Image
            
            img = Image.open(map_path)
            stats = map_path.stat()
            
            return {
                "name": map_path.stem,
                "size": img.size,
                "file_size": stats.st_size,
                "modified": time.ctime(stats.st_mtime),
                "path": str(map_path)
            }
            
        except Exception as e:
            return {"error": f"Erro ao obter informações: {e}"}
    
    def delete_map(self, map_name: str) -> bool:
        """
        Remove um mapa do diretório.
        
        Args:
            map_name: Nome do mapa (com ou sem extensão)
            
        Returns:
            bool: True se removido com sucesso
        """
        try:
            if not map_name.endswith('.png'):
                map_name += '.png'
            
            map_path = self.mapas_dir / map_name
            if map_path.exists():
                map_path.unlink()
                
                # Remover arquivos .map associados se existirem
                base_name = map_name.rsplit('.', 1)[0]
                for ext in ['.map', '_fogo.map', '_vento.map']:
                    map_file = self.mapas_dir / f"{base_name}{ext}"
                    if map_file.exists():
                        map_file.unlink()
                
                return True
            return False
            
        except Exception as e:
            st.error(f"Erro ao remover mapa: {e}")
            return False
    
    def convert_existing_image(self, image_path: str, output_name: str) -> Dict[str, str]:
        """
        Converte uma imagem existente em arquivos de mapa.
        
        Args:
            image_path: Caminho para a imagem
            output_name: Nome base para os arquivos de saída
            
        Returns:
            Dict[str, str]: Caminhos dos arquivos gerados
        """
        try:
            from map_converter_utils import converter_mapa
            
            # Converter usando o módulo original
            output_path = self.mapas_dir / output_name
            converter_mapa(image_path, str(output_path))
            
            # Verificar arquivos gerados
            generated_files = {}
            map_files = {
                "main": f"{output_name}.map",
                "fire": f"{output_name}_fogo.map",
                "wind": f"{output_name}_vento.map",
                "png": f"{output_name}.png"
            }
            
            for key, filename in map_files.items():
                file_path = self.mapas_dir / filename
                if file_path.exists():
                    generated_files[key] = str(file_path)
            
            return generated_files
            
        except Exception as e:
            raise Exception(f"Erro na conversão: {e}")
    
    def get_available_templates(self) -> Dict[str, Dict[str, any]]:
        """
        Retorna templates disponíveis para criação de mapas.
        
        Returns:
            Dict: Templates disponíveis
        """
        return {
            "empty": {
                "name": "Mapa Vazio",
                "description": "Mapa completamente branco para criação personalizada",
                "default_size": (20, 20)
            },
            "room": {
                "name": "Sala Simples",
                "description": "Sala com paredes externas e uma porta",
                "default_size": (15, 20)
            },
            "corridor": {
                "name": "Corredor",
                "description": "Corredor com paredes laterais e portas nas extremidades",
                "default_size": (25, 10)
            }
        }

# Instância global do serviço
tkinter_map_editor_service = TkinterMapEditorIntegration()

